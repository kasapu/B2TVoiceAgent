# Orchestrator - Implementation Guide

## Overview
The Orchestrator manages dialog flows, state machines, business logic, and coordinates between NLU, integrations, and response generation.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Orchestrator                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐      ┌──────────────┐                    │
│  │  Workflow    │      │   Dialog     │                    │
│  │  Engine      │◄────►│   Manager    │                    │
│  └──────┬───────┘      └──────┬───────┘                    │
│         │                     │                             │
│         │      ┌──────────────▼───────────┐                │
│         │      │   State Machine          │                │
│         │      │   • Current State        │                │
│         │      │   • Transitions          │                │
│         │      │   • State History        │                │
│         │      └──────────┬───────────────┘                │
│         │                 │                                 │
│  ┌──────▼─────────────────▼───────────┐                    │
│  │   Execution Context                │                    │
│  │   • Variables                      │                    │
│  │   • Session Data                   │                    │
│  │   • User Data                      │                    │
│  └──────┬─────────────────────────────┘                    │
│         │                                                   │
│  ┌──────▼─────────────────────────────┐                    │
│  │   Action Handlers                  │                    │
│  │   • API Calls                      │                    │
│  │   • Slot Filling                   │                    │
│  │   • Conditional Logic              │                    │
│  │   • Response Generation            │                    │
│  └────────────────────────────────────┘                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Core Components

### 1. Workflow Definition

```python
# models/workflow.py
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field
from enum import Enum

class StepType(str, Enum):
    """Types of workflow steps"""
    AUTH = "auth"
    SLOT_FILL = "slot_fill"
    API_CALL = "api_call"
    CONDITION = "condition"
    RESPONSE = "response"
    CUSTOM_ACTION = "custom_action"
    LOOP = "loop"
    GOTO = "goto"
    WAIT_INPUT = "wait_input"
    WEBHOOK = "webhook"

class WorkflowStep(BaseModel):
    """Individual workflow step"""
    id: str
    type: StepType
    name: Optional[str] = None
    
    # Authentication
    auth_provider: Optional[str] = None
    
    # Slot filling
    slot: Optional[str] = None
    prompt: Optional[str] = None
    validation: Optional[Dict[str, Any]] = None
    retry_limit: int = 3
    
    # API call
    integration: Optional[str] = None
    endpoint: Optional[str] = None
    method: str = "GET"
    request_body: Optional[Dict[str, Any]] = None
    headers: Optional[Dict[str, Any]] = None
    response_mapping: Optional[Dict[str, str]] = None
    
    # Conditional logic
    condition: Optional[str] = None  # Python expression
    if_true: Optional[str] = None  # Next step ID
    if_false: Optional[str] = None  # Next step ID
    
    # Response
    template: Optional[str] = None
    response_text: Optional[str] = None
    
    # Custom action
    action_name: Optional[str] = None
    parameters: Optional[Dict[str, Any]] = None
    
    # Loop
    loop_condition: Optional[str] = None
    loop_steps: Optional[List[str]] = None
    max_iterations: int = 10
    
    # Navigation
    next_step: Optional[str] = None
    on_error: Optional[str] = None
    
    # Metadata
    timeout: int = 30
    retry_on_failure: bool = False
    critical: bool = True

class Workflow(BaseModel):
    """Complete workflow definition"""
    workflow_id: str
    name: str
    description: Optional[str] = None
    trigger_intent: str
    steps: List[WorkflowStep]
    variables: Dict[str, Any] = Field(default_factory=dict)
    timeout: int = 300  # 5 minutes default
    error_handling: Optional[Dict[str, Any]] = None

# Workflow examples
BANKING_TRANSFER_WORKFLOW = {
    "workflow_id": "banking_transfer_v1",
    "name": "Money Transfer",
    "trigger_intent": "transfer_money",
    "steps": [
        {
            "id": "auth",
            "type": "auth",
            "auth_provider": "mfa",
            "next_step": "validate_accounts",
            "on_error": "auth_failed"
        },
        {
            "id": "validate_accounts",
            "type": "custom_action",
            "action_name": "validate_account_access",
            "next_step": "check_amount",
            "on_error": "invalid_account"
        },
        {
            "id": "check_amount",
            "type": "condition",
            "condition": "variables['amount'] > 0 and variables['amount'] <= 50000",
            "if_true": "get_from_account",
            "if_false": "invalid_amount"
        },
        {
            "id": "get_from_account",
            "type": "slot_fill",
            "slot": "from_account",
            "prompt": "Which account would you like to transfer from?",
            "validation": {"type": "account_exists"},
            "next_step": "get_to_account"
        },
        {
            "id": "get_to_account",
            "type": "slot_fill",
            "slot": "to_account",
            "prompt": "Which account would you like to transfer to?",
            "validation": {"type": "account_exists"},
            "next_step": "check_sufficient_funds"
        },
        {
            "id": "check_sufficient_funds",
            "type": "api_call",
            "integration": "core_banking",
            "endpoint": "/accounts/{from_account}/balance",
            "response_mapping": {"balance": "current_balance"},
            "next_step": "verify_balance"
        },
        {
            "id": "verify_balance",
            "type": "condition",
            "condition": "variables['current_balance'] >= variables['amount']",
            "if_true": "confirm_transfer",
            "if_false": "insufficient_funds"
        },
        {
            "id": "confirm_transfer",
            "type": "response",
            "template": "confirm_transfer_template",
            "next_step": "wait_confirmation"
        },
        {
            "id": "wait_confirmation",
            "type": "wait_input",
            "next_step": "check_confirmation"
        },
        {
            "id": "check_confirmation",
            "type": "condition",
            "condition": "intent == 'confirm' or 'yes' in text.lower()",
            "if_true": "execute_transfer",
            "if_false": "cancel_transfer"
        },
        {
            "id": "execute_transfer",
            "type": "api_call",
            "integration": "core_banking",
            "endpoint": "/transfers",
            "method": "POST",
            "request_body": {
                "from_account": "{from_account}",
                "to_account": "{to_account}",
                "amount": "{amount}"
            },
            "response_mapping": {"transaction_id": "transfer_id"},
            "next_step": "transfer_success"
        },
        {
            "id": "transfer_success",
            "type": "response",
            "template": "transfer_success_template",
            "next_step": None
        },
        {
            "id": "insufficient_funds",
            "type": "response",
            "response_text": "I'm sorry, but you don't have sufficient funds for this transfer.",
            "next_step": None
        },
        {
            "id": "cancel_transfer",
            "type": "response",
            "response_text": "Transfer cancelled. Is there anything else I can help you with?",
            "next_step": None
        },
        {
            "id": "auth_failed",
            "type": "response",
            "response_text": "Authentication failed. Please try again or contact support.",
            "next_step": None
        }
    ]
}
```

### 2. Orchestrator Engine

```python
# services/orchestrator.py
from typing import Dict, Any, Optional, Callable
from models.workflow import Workflow, WorkflowStep, StepType
import asyncio
from datetime import datetime
import re

class ExecutionContext:
    """Context for workflow execution"""
    
    def __init__(self, session_id: str, user_id: str):
        self.session_id = session_id
        self.user_id = user_id
        self.variables = {}
        self.step_history = []
        self.current_step = None
        self.metadata = {}
        self.started_at = datetime.utcnow()
    
    def set_variable(self, name: str, value: Any):
        """Set a variable in context"""
        self.variables[name] = value
    
    def get_variable(self, name: str, default=None):
        """Get a variable from context"""
        return self.variables.get(name, default)
    
    def add_to_history(self, step_id: str, result: Any):
        """Add step to history"""
        self.step_history.append({
            'step_id': step_id,
            'result': result,
            'timestamp': datetime.utcnow()
        })

class OrchestratorEngine:
    """Main orchestration engine"""
    
    def __init__(
        self,
        integration_manager,
        auth_service,
        response_generator,
        state_manager
    ):
        self.integration_manager = integration_manager
        self.auth_service = auth_service
        self.response_generator = response_generator
        self.state_manager = state_manager
        self.workflows = {}
        self.action_handlers = {}
    
    def register_workflow(self, workflow: Workflow):
        """Register a workflow"""
        self.workflows[workflow.workflow_id] = workflow
    
    def register_action_handler(
        self,
        action_name: str,
        handler: Callable
    ):
        """Register custom action handler"""
        self.action_handlers[action_name] = handler
    
    async def execute_workflow(
        self,
        workflow_id: str,
        nlu_result: Any,
        session_id: str,
        user_id: str,
        initial_context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute a workflow
        
        Args:
            workflow_id: ID of workflow to execute
            nlu_result: NLU processing result
            session_id: Session ID
            user_id: User ID
            initial_context: Initial context variables
        
        Returns:
            Execution result with response and updated context
        """
        workflow = self.workflows.get(workflow_id)
        if not workflow:
            raise ValueError(f"Workflow {workflow_id} not found")
        
        # Create execution context
        context = ExecutionContext(session_id, user_id)
        
        # Initialize variables from NLU
        context.variables.update({
            'intent': nlu_result.intent,
            'entities': nlu_result.entities,
            'text': nlu_result.text,
            'confidence': nlu_result.confidence
        })
        
        # Add entities to variables
        context.variables.update(nlu_result.entities)
        
        # Add initial context
        if initial_context:
            context.variables.update(initial_context)
        
        # Execute workflow steps
        current_step_id = workflow.steps[0].id
        response = None
        
        while current_step_id:
            step = self._get_step(workflow, current_step_id)
            
            try:
                # Execute step
                step_result = await self._execute_step(
                    workflow,
                    step,
                    context
                )
                
                # Add to history
                context.add_to_history(current_step_id, step_result)
                
                # Get next step
                current_step_id = self._get_next_step(
                    step,
                    step_result,
                    context
                )
                
                # If response step, save response
                if step.type == StepType.RESPONSE:
                    response = step_result
                
            except Exception as e:
                # Handle error
                if step.on_error:
                    current_step_id = step.on_error
                else:
                    raise
        
        # Save state
        await self.state_manager.save_state(
            session_id=session_id,
            context=context.variables,
            workflow_id=workflow_id
        )
        
        return {
            'response': response,
            'context': context.variables,
            'completed': True
        }
    
    def _get_step(self, workflow: Workflow, step_id: str) -> WorkflowStep:
        """Get step by ID"""
        for step in workflow.steps:
            if step.id == step_id:
                return step
        raise ValueError(f"Step {step_id} not found")
    
    async def _execute_step(
        self,
        workflow: Workflow,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> Any:
        """Execute a single workflow step"""
        if step.type == StepType.AUTH:
            return await self._execute_auth(step, context)
        
        elif step.type == StepType.SLOT_FILL:
            return await self._execute_slot_fill(step, context)
        
        elif step.type == StepType.API_CALL:
            return await self._execute_api_call(step, context)
        
        elif step.type == StepType.CONDITION:
            return await self._execute_condition(step, context)
        
        elif step.type == StepType.RESPONSE:
            return await self._execute_response(step, context)
        
        elif step.type == StepType.CUSTOM_ACTION:
            return await self._execute_custom_action(step, context)
        
        elif step.type == StepType.WAIT_INPUT:
            return await self._execute_wait_input(step, context)
        
        elif step.type == StepType.WEBHOOK:
            return await self._execute_webhook(step, context)
        
        else:
            raise ValueError(f"Unknown step type: {step.type}")
    
    async def _execute_auth(
        self,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> bool:
        """Execute authentication step"""
        is_authenticated = await self.auth_service.verify_user(
            user_id=context.user_id,
            provider=step.auth_provider
        )
        
        context.set_variable('authenticated', is_authenticated)
        return is_authenticated
    
    async def _execute_slot_fill(
        self,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> Optional[str]:
        """Execute slot filling step"""
        # Check if slot already filled
        slot_value = context.get_variable(step.slot)
        
        if slot_value is None:
            # Need to ask user
            prompt = self._render_template(step.prompt, context.variables)
            context.set_variable('_waiting_for_slot', step.slot)
            context.set_variable('_slot_prompt', prompt)
            return None
        
        # Validate slot value
        if step.validation:
            is_valid = await self._validate_slot(
                slot_value,
                step.validation
            )
            
            if not is_valid:
                # Invalid, need to ask again
                return None
        
        return slot_value
    
    async def _execute_api_call(
        self,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> Dict[str, Any]:
        """Execute API call step"""
        # Get integration
        integration = await self.integration_manager.get(step.integration)
        
        # Render endpoint with variables
        endpoint = self._render_template(step.endpoint, context.variables)
        
        # Prepare request
        headers = step.headers or {}
        body = None
        
        if step.request_body:
            body = self._render_template_dict(
                step.request_body,
                context.variables
            )
        
        # Make API call
        response = await integration.request(
            method=step.method,
            endpoint=endpoint,
            headers=headers,
            json=body
        )
        
        # Map response to variables
        if step.response_mapping:
            for target_var, source_path in step.response_mapping.items():
                value = self._extract_from_response(response, source_path)
                context.set_variable(target_var, value)
        
        return response
    
    async def _execute_condition(
        self,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> bool:
        """Execute conditional step"""
        # Evaluate condition
        condition = step.condition
        
        # Replace variable references
        for var_name, var_value in context.variables.items():
            condition = condition.replace(
                f"variables['{var_name}']",
                repr(var_value)
            )
        
        # Safely evaluate
        try:
            result = eval(condition, {"__builtins__": {}}, context.variables)
            return bool(result)
        except Exception as e:
            print(f"Error evaluating condition: {e}")
            return False
    
    async def _execute_response(
        self,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> str:
        """Execute response generation step"""
        if step.response_text:
            response = self._render_template(
                step.response_text,
                context.variables
            )
        elif step.template:
            response = await self.response_generator.generate(
                template_name=step.template,
                variables=context.variables
            )
        else:
            raise ValueError("Response step requires either response_text or template")
        
        return response
    
    async def _execute_custom_action(
        self,
        step: WorkflowStep,
        context: ExecutionContext
    ) -> Any:
        """Execute custom action"""
        handler = self.action_handlers.get(step.action_name)
        if not handler:
            raise ValueError(f"Action handler {step.action_name} not found")
        
        params = step.parameters or {}
        params = self._render_template_dict(params, context.variables)
        
        result = await handler(context, **params)
        return result
    
    def _get_next_step(
        self,
        step: WorkflowStep,
        step_result: Any,
        context: ExecutionContext
    ) -> Optional[str]:
        """Determine next step based on current step result"""
        if step.type == StepType.CONDITION:
            return step.if_true if step_result else step.if_false
        
        return step.next_step
    
    def _render_template(self, template: str, variables: Dict[str, Any]) -> str:
        """Render template with variables"""
        result = template
        for key, value in variables.items():
            result = result.replace(f"{{{key}}}", str(value))
        return result
    
    def _render_template_dict(
        self,
        template_dict: Dict[str, Any],
        variables: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Render dictionary template with variables"""
        result = {}
        for key, value in template_dict.items():
            if isinstance(value, str):
                result[key] = self._render_template(value, variables)
            elif isinstance(value, dict):
                result[key] = self._render_template_dict(value, variables)
            else:
                result[key] = value
        return result
    
    def _extract_from_response(
        self,
        response: Dict[str, Any],
        path: str
    ) -> Any:
        """Extract value from response using dot notation path"""
        parts = path.split('.')
        current = response
        for part in parts:
            current = current.get(part)
            if current is None:
                return None
        return current

# State Manager
class StateManager:
    """Manage workflow state persistence"""
    
    def __init__(self, redis_client):
        self.redis = redis_client
    
    async def save_state(
        self,
        session_id: str,
        context: Dict[str, Any],
        workflow_id: str
    ):
        """Save workflow state"""
        state = {
            'context': context,
            'workflow_id': workflow_id,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        await self.redis.setex(
            f"workflow_state:{session_id}",
            3600,  # 1 hour TTL
            json.dumps(state)
        )
    
    async def get_state(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get workflow state"""
        data = await self.redis.get(f"workflow_state:{session_id}")
        if data:
            return json.loads(data)
        return None
```

### 3. API Endpoints

```python
# api/routes/orchestrator.py
from fastapi import APIRouter, HTTPException, Depends, WebSocket
from typing import Optional
from services.orchestrator import OrchestratorEngine

router = APIRouter(prefix="/api/v1/orchestrator", tags=["Orchestrator"])

@router.post("/execute")
async def execute_workflow(
    workflow_id: str,
    intent: str,
    entities: dict,
    text: str,
    session_id: str,
    user_id: str,
    orchestrator: OrchestratorEngine = Depends()
):
    """Execute a workflow"""
    from services.nlu_service import NLUResult
    
    nlu_result = NLUResult(
        text=text,
        intent=intent,
        confidence=0.9,
        entities=entities,
        sentiment="neutral",
        sentiment_score=0.5,
        language="en",
        context={}
    )
    
    try:
        result = await orchestrator.execute_workflow(
            workflow_id=workflow_id,
            nlu_result=nlu_result,
            session_id=session_id,
            user_id=user_id
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.websocket("/ws/{session_id}")
async def workflow_websocket(
    websocket: WebSocket,
    session_id: str
):
    """WebSocket for interactive workflow execution"""
    await websocket.accept()
    
    try:
        while True:
            data = await websocket.receive_json()
            
            # Process message through NLU and orchestrator
            # Send response back
            await websocket.send_json({
                'response': 'Processing...',
                'status': 'ok'
            })
    except Exception as e:
        await websocket.close()
```

This Orchestrator provides robust workflow management with state machines and business logic. Continue with Integrations next?
