# B2T Mini VoiceAgents - Implementation Guide

## Overview
B2T Mini VoiceAgents enable rapid deployment of pre-configured conversational AI agents through templates and configuration-driven setup.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│           B2T Mini VoiceAgents System                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌────────────────┐     ┌────────────────┐            │
│  │   Template     │     │   Agent        │            │
│  │   Library      │────▶│   Factory      │            │
│  └────────────────┘     └────────┬───────┘            │
│                                   │                     │
│  ┌────────────────┐              │                     │
│  │   Config       │              │                     │
│  │   Schema       │──────────────┤                     │
│  └────────────────┘              │                     │
│                                   │                     │
│                        ┌──────────▼───────────┐        │
│                        │   Agent Instance     │        │
│                        │   • State            │        │
│                        │   • Intents          │        │
│                        │   • Entities         │        │
│                        │   • Workflows        │        │
│                        └──────────┬───────────┘        │
│                                   │                     │
│                        ┌──────────▼───────────┐        │
│                        │   Deployment         │        │
│                        │   Manager            │        │
│                        └──────────────────────┘        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## Core Components

### 1. Agent Template Schema

```json
{
  "templateId": "banking_assistant_v1",
  "name": "Banking Assistant",
  "description": "Handle balance inquiries, transfers, and account management",
  "category": "financial_services",
  "version": "1.0.0",
  "icon": "bank",
  "metadata": {
    "industry": "banking",
    "useCase": "customer_service",
    "complexity": "medium",
    "estimatedSetupTime": "5-10 minutes"
  },
  "configuration": {
    "nlu": {
      "provider": "rasa",
      "model": "en_core_web_lg",
      "confidence_threshold": 0.7
    },
    "intents": [
      {
        "name": "check_balance",
        "examples": [
          "What is my account balance?",
          "How much money do I have?",
          "Show me my balance"
        ],
        "slots": ["account_type"],
        "action": "action_check_balance"
      },
      {
        "name": "transfer_money",
        "examples": [
          "Transfer money to savings",
          "Move funds between accounts",
          "Send money to another account"
        ],
        "slots": ["from_account", "to_account", "amount"],
        "action": "action_transfer_money"
      },
      {
        "name": "account_statement",
        "examples": [
          "Send me my statement",
          "I need my transaction history",
          "Show recent transactions"
        ],
        "slots": ["account_type", "date_range"],
        "action": "action_get_statement"
      }
    ],
    "entities": [
      {
        "name": "account_type",
        "type": "categorical",
        "values": ["checking", "savings", "credit"]
      },
      {
        "name": "amount",
        "type": "number",
        "validation": {
          "min": 1,
          "max": 50000
        }
      },
      {
        "name": "date_range",
        "type": "date_period",
        "format": "last_n_days"
      }
    ],
    "workflows": [
      {
        "name": "balance_inquiry_flow",
        "steps": [
          {
            "id": "authenticate",
            "type": "auth",
            "action": "verify_user"
          },
          {
            "id": "get_account_type",
            "type": "slot_fill",
            "slot": "account_type",
            "prompt": "Which account would you like to check?"
          },
          {
            "id": "fetch_balance",
            "type": "api_call",
            "integration": "core_banking_api",
            "endpoint": "/accounts/{account_id}/balance"
          },
          {
            "id": "respond",
            "type": "response",
            "template": "balance_response"
          }
        ]
      }
    ],
    "integrations": [
      {
        "name": "core_banking_api",
        "type": "rest",
        "required": true,
        "config": {
          "baseUrl": "{{BANKING_API_URL}}",
          "auth": "oauth2",
          "endpoints": [
            "/accounts/{account_id}/balance",
            "/accounts/{account_id}/transactions",
            "/transfers"
          ]
        }
      }
    ],
    "responses": {
      "balance_response": {
        "text": "Your {{account_type}} account balance is ${{balance}}. Is there anything else I can help you with?",
        "voice": "Your {{account_type}} account balance is {{balance}} dollars.",
        "fallback": "I was unable to retrieve your balance. Please try again later."
      }
    }
  }
}
```

### 2. Python Implementation

```python
# models/agent_template.py
from typing import List, Dict, Optional, Any
from pydantic import BaseModel, Field
from enum import Enum
from datetime import datetime

class IntentExample(BaseModel):
    text: str
    entities: Optional[List[Dict[str, Any]]] = []

class Intent(BaseModel):
    name: str
    examples: List[str]
    slots: List[str] = []
    action: str
    confidence_threshold: float = 0.7

class Entity(BaseModel):
    name: str
    type: str  # categorical, number, date_period, custom
    values: Optional[List[str]] = None
    validation: Optional[Dict[str, Any]] = None

class WorkflowStep(BaseModel):
    id: str
    type: str  # auth, slot_fill, api_call, response, condition
    action: Optional[str] = None
    slot: Optional[str] = None
    prompt: Optional[str] = None
    integration: Optional[str] = None
    endpoint: Optional[str] = None
    template: Optional[str] = None
    condition: Optional[Dict[str, Any]] = None

class Workflow(BaseModel):
    name: str
    description: Optional[str] = None
    steps: List[WorkflowStep]
    error_handling: Optional[Dict[str, Any]] = None

class Integration(BaseModel):
    name: str
    type: str  # rest, graphql, websocket, database
    required: bool = True
    config: Dict[str, Any]

class AgentTemplate(BaseModel):
    template_id: str = Field(alias="templateId")
    name: str
    description: str
    category: str
    version: str
    icon: str
    metadata: Dict[str, Any]
    configuration: Dict[str, Any]
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        populate_by_name = True

# services/agent_factory.py
from typing import Optional
import uuid
from models.agent_template import AgentTemplate
from models.agent_instance import AgentInstance

class AgentFactory:
    """Factory for creating agent instances from templates"""
    
    def __init__(self, template_repository, nlu_service, orchestrator):
        self.template_repository = template_repository
        self.nlu_service = nlu_service
        self.orchestrator = orchestrator
    
    async def create_agent(
        self,
        template_id: str,
        name: str,
        user_config: Optional[Dict[str, Any]] = None
    ) -> AgentInstance:
        """
        Create a new agent instance from a template
        
        Args:
            template_id: ID of the template to use
            name: Name for the new agent
            user_config: Optional user-provided configuration overrides
        
        Returns:
            AgentInstance: Newly created agent instance
        """
        # Load template
        template = await self.template_repository.get(template_id)
        if not template:
            raise ValueError(f"Template {template_id} not found")
        
        # Generate unique agent ID
        agent_id = f"agent_{uuid.uuid4().hex[:12]}"
        
        # Merge template config with user config
        config = self._merge_configs(template.configuration, user_config or {})
        
        # Create agent instance
        agent = AgentInstance(
            agent_id=agent_id,
            name=name,
            template_id=template_id,
            configuration=config,
            status="draft"
        )
        
        # Initialize NLU model
        await self._initialize_nlu(agent, template)
        
        # Setup workflows in orchestrator
        await self._setup_workflows(agent, template)
        
        # Validate integrations
        await self._validate_integrations(agent, template)
        
        return agent
    
    def _merge_configs(
        self,
        template_config: Dict[str, Any],
        user_config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Merge template and user configurations"""
        merged = template_config.copy()
        
        # Deep merge user config
        for key, value in user_config.items():
            if isinstance(value, dict) and key in merged:
                merged[key].update(value)
            else:
                merged[key] = value
        
        return merged
    
    async def _initialize_nlu(
        self,
        agent: AgentInstance,
        template: AgentTemplate
    ):
        """Initialize NLU model for the agent"""
        intents = template.configuration.get("intents", [])
        entities = template.configuration.get("entities", [])
        
        # Train NLU model
        nlu_model = await self.nlu_service.train_model(
            agent_id=agent.agent_id,
            intents=intents,
            entities=entities
        )
        
        agent.nlu_model_id = nlu_model.model_id
    
    async def _setup_workflows(
        self,
        agent: AgentInstance,
        template: AgentTemplate
    ):
        """Setup workflows in orchestrator"""
        workflows = template.configuration.get("workflows", [])
        
        for workflow in workflows:
            await self.orchestrator.register_workflow(
                agent_id=agent.agent_id,
                workflow=workflow
            )
    
    async def _validate_integrations(
        self,
        agent: AgentInstance,
        template: AgentTemplate
    ):
        """Validate that required integrations are configured"""
        integrations = template.configuration.get("integrations", [])
        
        for integration in integrations:
            if integration.get("required", False):
                # Check if user has provided credentials/config
                if not self._has_integration_config(agent, integration["name"]):
                    raise ValueError(
                        f"Required integration '{integration['name']}' is not configured"
                    )
    
    def _has_integration_config(
        self,
        agent: AgentInstance,
        integration_name: str
    ) -> bool:
        """Check if integration is configured"""
        integrations = agent.configuration.get("integrations", {})
        return integration_name in integrations

# api/routes/mini_agents.py
from fastapi import APIRouter, HTTPException, Depends, status
from typing import List, Optional
from models.agent_template import AgentTemplate
from models.agent_instance import AgentInstance
from services.agent_factory import AgentFactory
from services.deployment_manager import DeploymentManager

router = APIRouter(prefix="/api/v1/mini-agents", tags=["Mini Agents"])

@router.get("/templates", response_model=List[AgentTemplate])
async def list_templates(
    category: Optional[str] = None,
    search: Optional[str] = None
):
    """List available agent templates"""
    templates = await template_repository.list(
        category=category,
        search=search
    )
    return templates

@router.get("/templates/{template_id}", response_model=AgentTemplate)
async def get_template(template_id: str):
    """Get a specific template"""
    template = await template_repository.get(template_id)
    if not template:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Template {template_id} not found"
        )
    return template

@router.post("/agents", response_model=AgentInstance, status_code=status.HTTP_201_CREATED)
async def create_agent(
    template_id: str,
    name: str,
    config: Optional[Dict[str, Any]] = None,
    agent_factory: AgentFactory = Depends()
):
    """Create a new agent from template"""
    try:
        agent = await agent_factory.create_agent(
            template_id=template_id,
            name=name,
            user_config=config
        )
        return agent
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )

@router.post("/agents/{agent_id}/deploy")
async def deploy_agent(
    agent_id: str,
    deployment_manager: DeploymentManager = Depends()
):
    """Deploy an agent to production"""
    try:
        result = await deployment_manager.deploy(agent_id)
        return {
            "agent_id": agent_id,
            "status": "deployed",
            "endpoint": result.endpoint,
            "deployed_at": result.deployed_at
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Deployment failed: {str(e)}"
        )

@router.get("/agents", response_model=List[AgentInstance])
async def list_agents(
    status: Optional[str] = None,
    template_id: Optional[str] = None
):
    """List all agents"""
    agents = await agent_repository.list(
        status=status,
        template_id=template_id
    )
    return agents

@router.get("/agents/{agent_id}", response_model=AgentInstance)
async def get_agent(agent_id: str):
    """Get agent details"""
    agent = await agent_repository.get(agent_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Agent {agent_id} not found"
        )
    return agent

@router.put("/agents/{agent_id}/status")
async def update_agent_status(
    agent_id: str,
    status: str  # draft, active, paused, archived
):
    """Update agent status"""
    agent = await agent_repository.get(agent_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Agent {agent_id} not found"
        )
    
    agent.status = status
    await agent_repository.update(agent)
    
    return {"agent_id": agent_id, "status": status}

@router.delete("/agents/{agent_id}")
async def delete_agent(agent_id: str):
    """Delete an agent"""
    await agent_repository.delete(agent_id)
    return {"agent_id": agent_id, "status": "deleted"}
```

### 3. React Component (Frontend)

```typescript
// components/MiniAgents/AgentTemplateCard.tsx
import React from 'react';
import { Card, CardContent, CardActions, Button, Chip, Typography } from '@mui/material';
import { AgentTemplate } from '../../types/agents';

interface AgentTemplateCardProps {
  template: AgentTemplate;
  onSelect: (templateId: string) => void;
}

export const AgentTemplateCard: React.FC<AgentTemplateCardProps> = ({
  template,
  onSelect
}) => {
  return (
    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardContent sx={{ flexGrow: 1 }}>
        <div style={{ display: 'flex', alignItems: 'center', marginBottom: 16 }}>
          <div 
            style={{
              width: 48,
              height: 48,
              borderRadius: 8,
              background: template.icon_color || '#1976d2',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginRight: 16
            }}
          >
            <span style={{ fontSize: 24 }}>{template.icon}</span>
          </div>
          <div>
            <Typography variant="h6">{template.name}</Typography>
            <Chip 
              label={template.category} 
              size="small"
              sx={{ mt: 0.5 }}
            />
          </div>
        </div>
        
        <Typography variant="body2" color="text.secondary">
          {template.description}
        </Typography>
        
        <Typography variant="caption" display="block" sx={{ mt: 2 }}>
          Setup time: {template.metadata.estimatedSetupTime}
        </Typography>
      </CardContent>
      
      <CardActions>
        <Button 
          size="small" 
          onClick={() => onSelect(template.template_id)}
          variant="contained"
        >
          Use Template
        </Button>
        <Button size="small">Preview</Button>
      </CardActions>
    </Card>
  );
};

// components/MiniAgents/CreateAgentWizard.tsx
import React, { useState } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Stepper,
  Step,
  StepLabel,
  TextField,
  Select,
  MenuItem,
  FormControl,
  InputLabel
} from '@mui/material';
import { AgentTemplate } from '../../types/agents';
import { createAgent } from '../../api/agents';

interface CreateAgentWizardProps {
  open: boolean;
  template: AgentTemplate;
  onClose: () => void;
  onSuccess: (agentId: string) => void;
}

export const CreateAgentWizard: React.FC<CreateAgentWizardProps> = ({
  open,
  template,
  onClose,
  onSuccess
}) => {
  const [activeStep, setActiveStep] = useState(0);
  const [agentName, setAgentName] = useState('');
  const [integrations, setIntegrations] = useState({});
  const [loading, setLoading] = useState(false);

  const steps = ['Name Your Agent', 'Configure Integrations', 'Review & Deploy'];

  const handleNext = () => {
    setActiveStep((prev) => prev + 1);
  };

  const handleBack = () => {
    setActiveStep((prev) => prev - 1);
  };

  const handleCreate = async () => {
    setLoading(true);
    try {
      const agent = await createAgent({
        template_id: template.template_id,
        name: agentName,
        config: {
          integrations
        }
      });
      onSuccess(agent.agent_id);
      onClose();
    } catch (error) {
      console.error('Failed to create agent:', error);
    } finally {
      setLoading(false);
    }
  };

  const renderStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <TextField
            autoFocus
            margin="dense"
            label="Agent Name"
            fullWidth
            value={agentName}
            onChange={(e) => setAgentName(e.target.value)}
            placeholder="e.g., Customer Support Bot"
          />
        );
      case 1:
        return (
          <div>
            {template.configuration.integrations.map((integration) => (
              <FormControl fullWidth key={integration.name} sx={{ mt: 2 }}>
                <InputLabel>{integration.name}</InputLabel>
                <TextField
                  label={`${integration.name} API URL`}
                  fullWidth
                  onChange={(e) => setIntegrations({
                    ...integrations,
                    [integration.name]: {
                      baseUrl: e.target.value
                    }
                  })}
                />
              </FormControl>
            ))}
          </div>
        );
      case 2:
        return (
          <div>
            <Typography variant="h6">Review Configuration</Typography>
            <Typography>Name: {agentName}</Typography>
            <Typography>Template: {template.name}</Typography>
            <Typography>Integrations: {Object.keys(integrations).length}</Typography>
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
      <DialogTitle>Create Agent from {template.name}</DialogTitle>
      <DialogContent>
        <Stepper activeStep={activeStep} sx={{ pt: 3, pb: 5 }}>
          {steps.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
        {renderStepContent(activeStep)}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button
          onClick={handleBack}
          disabled={activeStep === 0}
        >
          Back
        </Button>
        <Button
          onClick={activeStep === steps.length - 1 ? handleCreate : handleNext}
          disabled={loading}
          variant="contained"
        >
          {activeStep === steps.length - 1 ? 'Create Agent' : 'Next'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

## Deployment Manager

```python
# services/deployment_manager.py
import asyncio
from typing import Optional
from datetime import datetime
from models.agent_instance import AgentInstance

class DeploymentManager:
    """Manages agent deployment lifecycle"""
    
    async def deploy(self, agent_id: str) -> DeploymentResult:
        """
        Deploy an agent to production
        
        Steps:
        1. Validate agent configuration
        2. Build deployment package
        3. Deploy to kubernetes/cloud
        4. Health check
        5. Update status
        """
        agent = await self.agent_repository.get(agent_id)
        
        # Validate
        await self._validate_deployment(agent)
        
        # Build deployment
        deployment_id = await self._build_deployment(agent)
        
        # Deploy
        endpoint = await self._deploy_to_infrastructure(deployment_id, agent)
        
        # Health check
        await self._health_check(endpoint)
        
        # Update agent status
        agent.status = "active"
        agent.endpoint = endpoint
        agent.deployed_at = datetime.utcnow()
        await self.agent_repository.update(agent)
        
        return DeploymentResult(
            agent_id=agent_id,
            endpoint=endpoint,
            deployed_at=agent.deployed_at
        )
```

This provides the foundation for your B2T Mini VoiceAgents system. Would you like me to continue with the NLU Engine, Orchestrator, Integrations, and Insights components?
