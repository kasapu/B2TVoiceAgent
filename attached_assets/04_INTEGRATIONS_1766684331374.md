# Integrations Framework - Implementation Guide

## Overview
The Integrations framework provides a unified interface for connecting to external services, APIs, databases, and third-party systems.

## Architecture

```
┌──────────────────────────────────────────────────────────┐
│              Integration Manager                         │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  ┌────────────────────────────────────────────┐         │
│  │  Integration Registry                      │         │
│  │  • REST APIs                               │         │
│  │  • GraphQL                                 │         │
│  │  • WebSockets                              │         │
│  │  • Databases                               │         │
│  │  • Message Queues                          │         │
│  └────────────────┬───────────────────────────┘         │
│                   │                                      │
│  ┌────────────────▼───────────────────────────┐         │
│  │  Connection Pool                           │         │
│  │  • HTTP Client Pool                        │         │
│  │  • DB Connection Pool                      │         │
│  │  • WebSocket Connections                   │         │
│  └────────────────┬───────────────────────────┘         │
│                   │                                      │
│  ┌────────────────▼───────────────────────────┐         │
│  │  Authentication Manager                    │         │
│  │  • OAuth 2.0                               │         │
│  │  • API Keys                                │         │
│  │  • JWT                                     │         │
│  │  • Basic Auth                              │         │
│  └────────────────┬───────────────────────────┘         │
│                   │                                      │
│  ┌────────────────▼───────────────────────────┐         │
│  │  Request/Response Pipeline                 │         │
│  │  • Retry Logic                             │         │
│  │  • Rate Limiting                           │         │
│  │  • Caching                                 │         │
│  │  • Error Handling                          │         │
│  │  • Logging & Metrics                       │         │
│  └────────────────────────────────────────────┘         │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

## Core Components

### 1. Integration Base Classes

```python
# models/integration.py
from typing import Dict, Any, Optional, List
from pydantic import BaseModel, Field
from enum import Enum
from abc import ABC, abstractmethod

class IntegrationType(str, Enum):
    """Types of integrations"""
    REST = "rest"
    GRAPHQL = "graphql"
    WEBSOCKET = "websocket"
    DATABASE = "database"
    MESSAGE_QUEUE = "message_queue"
    CUSTOM = "custom"

class AuthType(str, Enum):
    """Authentication types"""
    NONE = "none"
    API_KEY = "api_key"
    OAUTH2 = "oauth2"
    JWT = "jwt"
    BASIC = "basic"
    CUSTOM = "custom"

class IntegrationConfig(BaseModel):
    """Integration configuration"""
    integration_id: str
    name: str
    type: IntegrationType
    base_url: Optional[str] = None
    auth_type: AuthType
    auth_config: Dict[str, Any] = Field(default_factory=dict)
    headers: Dict[str, str] = Field(default_factory=dict)
    timeout: int = 30
    retry_config: Optional[Dict[str, Any]] = None
    rate_limit: Optional[Dict[str, Any]] = None
    cache_config: Optional[Dict[str, Any]] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)

# services/integrations/base.py
class BaseIntegration(ABC):
    """Base class for all integrations"""
    
    def __init__(self, config: IntegrationConfig):
        self.config = config
        self.client = None
    
    @abstractmethod
    async def connect(self):
        """Establish connection"""
        pass
    
    @abstractmethod
    async def disconnect(self):
        """Close connection"""
        pass
    
    @abstractmethod
    async def request(self, **kwargs) -> Any:
        """Make a request"""
        pass
    
    async def health_check(self) -> bool:
        """Check if integration is healthy"""
        try:
            await self.request(method="GET", endpoint="/health")
            return True
        except:
            return False

# REST Integration
class RESTIntegration(BaseIntegration):
    """REST API Integration"""
    
    def __init__(self, config: IntegrationConfig):
        super().__init__(config)
        self.session = None
    
    async def connect(self):
        """Create HTTP session"""
        import aiohttp
        
        timeout = aiohttp.ClientTimeout(total=self.config.timeout)
        self.session = aiohttp.ClientSession(
            timeout=timeout,
            headers=self.config.headers
        )
        
        # Add authentication
        await self._setup_auth()
    
    async def disconnect(self):
        """Close HTTP session"""
        if self.session:
            await self.session.close()
    
    async def request(
        self,
        method: str,
        endpoint: str,
        headers: Optional[Dict[str, str]] = None,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Any] = None
    ) -> Dict[str, Any]:
        """Make HTTP request"""
        url = f"{self.config.base_url}{endpoint}"
        
        # Merge headers
        request_headers = {**self.config.headers}
        if headers:
            request_headers.update(headers)
        
        # Apply retry logic
        retry_config = self.config.retry_config or {
            'max_retries': 3,
            'backoff_factor': 2
        }
        
        for attempt in range(retry_config['max_retries']):
            try:
                async with self.session.request(
                    method=method,
                    url=url,
                    headers=request_headers,
                    json=json,
                    params=params,
                    data=data
                ) as response:
                    response.raise_for_status()
                    return await response.json()
            
            except Exception as e:
                if attempt == retry_config['max_retries'] - 1:
                    raise
                
                # Exponential backoff
                await asyncio.sleep(
                    retry_config['backoff_factor'] ** attempt
                )
    
    async def _setup_auth(self):
        """Setup authentication"""
        if self.config.auth_type == AuthType.API_KEY:
            # Add API key to headers
            api_key_header = self.config.auth_config.get('header', 'X-API-Key')
            api_key = self.config.auth_config.get('key')
            self.config.headers[api_key_header] = api_key
        
        elif self.config.auth_type == AuthType.OAUTH2:
            # Get OAuth token
            token = await self._get_oauth_token()
            self.config.headers['Authorization'] = f"Bearer {token}"
        
        elif self.config.auth_type == AuthType.BASIC:
            # Add Basic auth
            import base64
            username = self.config.auth_config.get('username')
            password = self.config.auth_config.get('password')
            credentials = base64.b64encode(
                f"{username}:{password}".encode()
            ).decode()
            self.config.headers['Authorization'] = f"Basic {credentials}"
    
    async def _get_oauth_token(self) -> str:
        """Get OAuth 2.0 token"""
        token_url = self.config.auth_config.get('token_url')
        client_id = self.config.auth_config.get('client_id')
        client_secret = self.config.auth_config.get('client_secret')
        
        async with self.session.post(
            token_url,
            data={
                'grant_type': 'client_credentials',
                'client_id': client_id,
                'client_secret': client_secret
            }
        ) as response:
            data = await response.json()
            return data['access_token']

# GraphQL Integration
class GraphQLIntegration(BaseIntegration):
    """GraphQL API Integration"""
    
    async def connect(self):
        """Setup GraphQL client"""
        from gql import Client
        from gql.transport.aiohttp import AIOHTTPTransport
        
        transport = AIOHTTPTransport(
            url=self.config.base_url,
            headers=self.config.headers
        )
        
        self.client = Client(
            transport=transport,
            fetch_schema_from_transport=True
        )
    
    async def disconnect(self):
        """Close GraphQL client"""
        if self.client:
            await self.client.close_async()
    
    async def request(
        self,
        query: str,
        variables: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Execute GraphQL query"""
        from gql import gql
        
        result = await self.client.execute_async(
            gql(query),
            variable_values=variables
        )
        return result

# Database Integration
class DatabaseIntegration(BaseIntegration):
    """Database Integration"""
    
    async def connect(self):
        """Connect to database"""
        from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
        from sqlalchemy.orm import sessionmaker
        
        self.engine = create_async_engine(
            self.config.base_url,  # Connection string
            echo=False
        )
        
        self.SessionLocal = sessionmaker(
            self.engine,
            class_=AsyncSession,
            expire_on_commit=False
        )
    
    async def disconnect(self):
        """Close database connection"""
        if self.engine:
            await self.engine.dispose()
    
    async def request(
        self,
        query: str,
        params: Optional[Dict[str, Any]] = None
    ) -> List[Dict[str, Any]]:
        """Execute database query"""
        from sqlalchemy import text
        
        async with self.SessionLocal() as session:
            result = await session.execute(
                text(query),
                params or {}
            )
            return [dict(row) for row in result.fetchall()]

# WebSocket Integration
class WebSocketIntegration(BaseIntegration):
    """WebSocket Integration"""
    
    async def connect(self):
        """Connect to WebSocket"""
        import websockets
        
        self.ws = await websockets.connect(
            self.config.base_url,
            extra_headers=self.config.headers
        )
    
    async def disconnect(self):
        """Close WebSocket"""
        if self.ws:
            await self.ws.close()
    
    async def request(
        self,
        message: Dict[str, Any],
        wait_response: bool = True
    ) -> Optional[Dict[str, Any]]:
        """Send WebSocket message"""
        import json
        
        await self.ws.send(json.dumps(message))
        
        if wait_response:
            response = await self.ws.recv()
            return json.loads(response)
        
        return None

# Message Queue Integration
class MessageQueueIntegration(BaseIntegration):
    """Message Queue Integration (RabbitMQ, Kafka, etc.)"""
    
    async def connect(self):
        """Connect to message queue"""
        import aio_pika
        
        self.connection = await aio_pika.connect_robust(
            self.config.base_url
        )
        self.channel = await self.connection.channel()
    
    async def disconnect(self):
        """Close message queue connection"""
        if self.connection:
            await self.connection.close()
    
    async def request(
        self,
        queue: str,
        message: Dict[str, Any],
        wait_response: bool = False
    ) -> Optional[Dict[str, Any]]:
        """Publish message to queue"""
        import json
        import aio_pika
        
        await self.channel.default_exchange.publish(
            aio_pika.Message(
                body=json.dumps(message).encode()
            ),
            routing_key=queue
        )
        
        if wait_response:
            # Implement RPC pattern
            pass
        
        return None
```

### 2. Integration Manager

```python
# services/integration_manager.py
from typing import Dict, Any, Optional
from models.integration import IntegrationConfig, IntegrationType
from services.integrations.base import (
    BaseIntegration,
    RESTIntegration,
    GraphQLIntegration,
    DatabaseIntegration,
    WebSocketIntegration,
    MessageQueueIntegration
)

class IntegrationManager:
    """Manage all integrations"""
    
    def __init__(self):
        self.integrations: Dict[str, BaseIntegration] = {}
        self.configs: Dict[str, IntegrationConfig] = {}
    
    async def register(self, config: IntegrationConfig):
        """Register new integration"""
        # Create integration instance
        integration = self._create_integration(config)
        
        # Connect
        await integration.connect()
        
        # Store
        self.integrations[config.integration_id] = integration
        self.configs[config.integration_id] = config
    
    def _create_integration(
        self,
        config: IntegrationConfig
    ) -> BaseIntegration:
        """Create integration instance based on type"""
        if config.type == IntegrationType.REST:
            return RESTIntegration(config)
        elif config.type == IntegrationType.GRAPHQL:
            return GraphQLIntegration(config)
        elif config.type == IntegrationType.DATABASE:
            return DatabaseIntegration(config)
        elif config.type == IntegrationType.WEBSOCKET:
            return WebSocketIntegration(config)
        elif config.type == IntegrationType.MESSAGE_QUEUE:
            return MessageQueueIntegration(config)
        else:
            raise ValueError(f"Unknown integration type: {config.type}")
    
    async def get(self, integration_id: str) -> BaseIntegration:
        """Get integration by ID"""
        integration = self.integrations.get(integration_id)
        if not integration:
            raise ValueError(f"Integration {integration_id} not found")
        return integration
    
    async def remove(self, integration_id: str):
        """Remove integration"""
        integration = self.integrations.get(integration_id)
        if integration:
            await integration.disconnect()
            del self.integrations[integration_id]
            del self.configs[integration_id]
    
    async def health_check_all(self) -> Dict[str, bool]:
        """Check health of all integrations"""
        results = {}
        for integration_id, integration in self.integrations.items():
            results[integration_id] = await integration.health_check()
        return results
```

### 3. Pre-built Integration Connectors

```python
# services/integrations/connectors/salesforce.py
class SalesforceIntegration(RESTIntegration):
    """Salesforce CRM Integration"""
    
    def __init__(self, instance_url: str, client_id: str, client_secret: str):
        config = IntegrationConfig(
            integration_id="salesforce",
            name="Salesforce",
            type=IntegrationType.REST,
            base_url=f"{instance_url}/services/data/v58.0",
            auth_type=AuthType.OAUTH2,
            auth_config={
                'token_url': f"{instance_url}/services/oauth2/token",
                'client_id': client_id,
                'client_secret': client_secret
            }
        )
        super().__init__(config)
    
    async def create_lead(self, lead_data: Dict[str, Any]) -> str:
        """Create a new lead"""
        result = await self.request(
            method="POST",
            endpoint="/sobjects/Lead",
            json=lead_data
        )
        return result['id']
    
    async def get_account(self, account_id: str) -> Dict[str, Any]:
        """Get account details"""
        return await self.request(
            method="GET",
            endpoint=f"/sobjects/Account/{account_id}"
        )
    
    async def update_opportunity(
        self,
        opportunity_id: str,
        updates: Dict[str, Any]
    ):
        """Update opportunity"""
        await self.request(
            method="PATCH",
            endpoint=f"/sobjects/Opportunity/{opportunity_id}",
            json=updates
        )

# services/integrations/connectors/stripe.py
class StripeIntegration(RESTIntegration):
    """Stripe Payment Integration"""
    
    def __init__(self, api_key: str):
        config = IntegrationConfig(
            integration_id="stripe",
            name="Stripe",
            type=IntegrationType.REST,
            base_url="https://api.stripe.com/v1",
            auth_type=AuthType.BASIC,
            auth_config={
                'username': api_key,
                'password': ''
            }
        )
        super().__init__(config)
    
    async def create_payment_intent(
        self,
        amount: int,
        currency: str = "usd"
    ) -> Dict[str, Any]:
        """Create payment intent"""
        return await self.request(
            method="POST",
            endpoint="/payment_intents",
            data={
                'amount': amount,
                'currency': currency
            }
        )
    
    async def get_customer(self, customer_id: str) -> Dict[str, Any]:
        """Get customer details"""
        return await self.request(
            method="GET",
            endpoint=f"/customers/{customer_id}"
        )

# services/integrations/connectors/twilio.py
class TwilioIntegration(RESTIntegration):
    """Twilio SMS/Voice Integration"""
    
    def __init__(self, account_sid: str, auth_token: str):
        config = IntegrationConfig(
            integration_id="twilio",
            name="Twilio",
            type=IntegrationType.REST,
            base_url=f"https://api.twilio.com/2010-04-01/Accounts/{account_sid}",
            auth_type=AuthType.BASIC,
            auth_config={
                'username': account_sid,
                'password': auth_token
            }
        )
        super().__init__(config)
    
    async def send_sms(
        self,
        to: str,
        from_: str,
        body: str
    ) -> Dict[str, Any]:
        """Send SMS"""
        return await self.request(
            method="POST",
            endpoint="/Messages.json",
            data={
                'To': to,
                'From': from_,
                'Body': body
            }
        )

# services/integrations/connectors/hubspot.py
class HubSpotIntegration(RESTIntegration):
    """HubSpot CRM Integration"""
    
    def __init__(self, api_key: str):
        config = IntegrationConfig(
            integration_id="hubspot",
            name="HubSpot",
            type=IntegrationType.REST,
            base_url="https://api.hubapi.com",
            auth_type=AuthType.API_KEY,
            auth_config={
                'key': api_key,
                'header': 'Authorization',
                'format': f'Bearer {api_key}'
            }
        )
        super().__init__(config)
    
    async def create_contact(
        self,
        email: str,
        properties: Dict[str, Any]
    ) -> str:
        """Create contact"""
        result = await self.request(
            method="POST",
            endpoint="/crm/v3/objects/contacts",
            json={
                'properties': {
                    'email': email,
                    **properties
                }
            }
        )
        return result['id']
```

### 4. API Endpoints

```python
# api/routes/integrations.py
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from models.integration import IntegrationConfig
from services.integration_manager import IntegrationManager

router = APIRouter(prefix="/api/v1/integrations", tags=["Integrations"])

@router.post("/register")
async def register_integration(
    config: IntegrationConfig,
    manager: IntegrationManager = Depends()
):
    """Register new integration"""
    try:
        await manager.register(config)
        return {
            "integration_id": config.integration_id,
            "status": "registered"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/list")
async def list_integrations(
    manager: IntegrationManager = Depends()
):
    """List all registered integrations"""
    return [
        {
            'integration_id': config.integration_id,
            'name': config.name,
            'type': config.type
        }
        for config in manager.configs.values()
    ]

@router.get("/health")
async def health_check(
    manager: IntegrationManager = Depends()
):
    """Check health of all integrations"""
    results = await manager.health_check_all()
    return results

@router.delete("/{integration_id}")
async def remove_integration(
    integration_id: str,
    manager: IntegrationManager = Depends()
):
    """Remove integration"""
    await manager.remove(integration_id)
    return {"integration_id": integration_id, "status": "removed"}

@router.post("/{integration_id}/test")
async def test_integration(
    integration_id: str,
    test_request: dict,
    manager: IntegrationManager = Depends()
):
    """Test integration with sample request"""
    integration = await manager.get(integration_id)
    try:
        result = await integration.request(**test_request)
        return {"status": "success", "result": result}
    except Exception as e:
        return {"status": "error", "error": str(e)}
```

### 5. Integration Configuration UI

```typescript
// components/Integrations/IntegrationCard.tsx
import React from 'react';
import {
  Card,
  CardContent,
  Typography,
  Switch,
  Button,
  Chip
} from '@mui/material';
import { Integration } from '../../types/integration';

export const IntegrationCard: React.FC<{
  integration: Integration;
  onToggle: (id: string, enabled: boolean) => void;
  onConfigure: (id: string) => void;
}> = ({ integration, onToggle, onConfigure }) => {
  return (
    <Card>
      <CardContent>
        <div style={{ display: 'flex', justifyContent: 'space-between' }}>
          <div>
            <Typography variant="h6">{integration.name}</Typography>
            <Typography variant="body2" color="text.secondary">
              {integration.description}
            </Typography>
            <Chip
              label={integration.type}
              size="small"
              sx={{ mt: 1 }}
            />
          </div>
          <div>
            <Switch
              checked={integration.enabled}
              onChange={(e) => onToggle(integration.id, e.target.checked)}
            />
          </div>
        </div>
        <Button
          onClick={() => onConfigure(integration.id)}
          sx={{ mt: 2 }}
        >
          Configure
        </Button>
      </CardContent>
    </Card>
  );
};
```

This integration framework provides a flexible, extensible system for connecting to any external service. Continue with Insights & Analytics next?
